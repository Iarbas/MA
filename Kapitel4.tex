\chapter{Software-Entwicklung und Experimente}
Konzeptumsetzung, erste Messwerte für die Erstellung eines Modells. Dazu wird die verwendete Hardware und Software beschrieben sowie die App-Entwicklung und die Middleware des Roboters dokumentiert. Der Simulationsumgebung wird aufgrund ihres großen Umfanges das nächste Kapitel gewidmet. 

\section{Verwendete Hardware}
Da die Beacon-Technologie vorrangig zur Indoor-Lokalisierung von Personen eingesetzt wird und als Peripheriegerät meistens ein Smartphone Verwendung findet, wird auch ein solches für die gesamte Testdauer als Messgerät genutzt. Die Wahl fiel dabei auf ein Android-Smartphone mit dem Namen Motorola Moto G der gleichnamigen Firma Motorola Inc., weil es weit verbreitet ist und somit ein großer potentieller Nutzerkreis existiert. Zudem erfüllt es alle Hardware- und Software-Anforderungen zum Empfang von BLE-Signalen. Desweiteren werden zwei Roboter in den Experimenten genutzt, um die Messungen reproduzierbar und standardisiert durchzuführen. Für die reinen Distanz-Signalstärke-Messungen wird der Roboters, bzw. lediglich sein Arm namens "`Youbot"' der Kuka AG und später für die Validierung einer Beacon-Konfiguration der Roboter "`Scitos G5"' der MetraLabs GmbH verwendet. 
\subsection{Motorola Moto G}
Dieses Smartphone dient als Empfangsstation des Beacon-Signale. 
\begin{figure}[H]
\centering
%\includegraphics[scale=0.8]{Bilder/MotorolaAntenne}
%\caption{Anordnung der Atennen eines Motorola Moto G  \cite{Moto}}
%\label{fig:Moto}
%\begin{picture}(0,0)
%\put(80,240.5){Bluetooth- und WLAN-Atenne}
%\put(30,245.5){\color{red}\linethickness{0.6mm}\vector(1,0){45}}
%\end{picture}
\begin{tikzpicture}
\node [anchor=south west,inner sep=0] at (0,0) {\includegraphics[scale=0.8]{Bilder/MotorolaAntenne}};
\draw [red,->,line width=0.65mm] (3,7.415) -- (4.5,7.415);
\node [anchor=south west,inner sep=0, text width = 4cm] at (5,7) {Bluetooth- und WLAN-Antennen};
\end{tikzpicture}
\caption{Anordnung der Atennen an der Rückseite eines Motorola Moto G  \cite{Moto}}
\label{fig:Moto}
\end{figure}

!Atennencharackteristiken! Idee für die Erklärung der seltsamen Empfangsqualität bei den verschiednen Ausrichtungen: durch die Verteilung der Antennen ergibt sich auch eine Verteilung der Empfangscharackeristiken. Die dabei aufgenommenen Messwerte sehen bei den unterschiedlichen Ausrichtungen deshalb immer gleich aus, auch wenn die Signale aus einer anderen Richtung kommen, weil die Charackteristik speziell auf auf die normale Position optimiert wurde. Durch die Komplexität der Charackteristiken lässt sich dies nun schlecht visuell darstellen. Wenn man das Verhalten aber kennt (vorsicht, jedes Smartphone hat eine unterschiedliche Charakteristik), kann man Gegenmaßnahmen treffen. -> Heuristik 
\subsection{Youbot}
\begin{figure}[H] 
\centering
\includegraphics[scale=0.4]{Bilder/Youbot}
\caption{Youbot von der Kuka AG \cite{You}}
\end{figure}
\subsection{Scitos G5}
\begin{figure}[H] 
\centering
\includegraphics[scale=0.2]{Bilder/Scitos}
\caption{Scitos G5 von der MetraLabs GmbH}
\end{figure}

\section{Verwendete Software}
Um die Hardware zu nutzen und das geplante Konzept umzusetzen, benötigt es einer Kommunikation zwischen den Geräten und weiterer Werkzeuge zur Aufnahme von Messungen und deren Verarbeitung. Bei der Umsetzung wurde besonders auf Konfirmität der verschiedenen Systeme und deren reibungslosen Zusammenspiels geachtet. Um eine gemeinsame Basis zu schaffen, wurde das Software-Framework "`Robots Operating System"'(ROS) verwendet. Mit einem gemeinsamen Standard lassen sich die Messungen besser vergleichen, wodurch ihre Qualität und Aussagekraft zunimmt. Die Messungen müssen dabei auf der Smartphone-Plattform und den Roboter-Plattformen aufgenommen und  diese synchronisiert werden. Während ROS die übergeordnete Schnittstelle darstellt, müssen auf den einzelnen Hardware-Elementen die Messungen eigenständig durchgeführt werden. Die Messung auf dem Scitos-Roboter entfällt dabei auf die Software "`Miracenter"' und funktioniert ohne weiteres. Die Software für die Messungen auf dem Smartphone ist hingegen nicht vorgefertig und muss mithilfe eines Editors für Android-Applikationen und einer speziellen Bibliothek für die Kommunikation Smartphone $\rightarrow$ Estimote Beacon entwickelt werden.
\subsection{ROS}
Hier wird ROS erklärt.
\subsection{Miracenter}
\begin{wrapfigure}{r}{7cm}
\centering
\includegraphics[scale=0.9]{Bilder/Flur}
\caption{Grundriss eines Flures in Gebäude 29 der OvGU, Stockwerk 3}
\label{fig:Flur}
\end{wrapfigure}
Mit der Software "`Miracenter"' der Firma MetraLabs GmbH ist es möglich, mit einem Scitos G5 Roboter den Grundriss eines Raumes zu erstellen. Als Sensorinformationen bezieht die Software Daten von den Inertailsensoren, Schrittmotoren und des Laserscanners und kombiniert diese zu einer Karte. Dabei wird mithilfe der Schrittmotoren der zurückgelegte Weg gemessen und diese Information mit den Inertialsensoren verbessert. Der Laserscanner sucht Erklärung der Funktionsweise des Frameworksdabei nach festen Objekten und misst die Entfernung vom Roboter zu den Objekten. Im nebenstehendem Bild ist eine solche Karte als Beispiel aufgeführt. Die Daten die Miracenter dem Nutzer zur Verfügung stellt, bestehen aus der Position des Roboters und seiner Ausrichtung in der Karte. Die Karte liegt dabei als PNG-Datei vor, wobei ein Pixel einer konstanten metrischen Länge entspricht. Die Farbwerte der Bildpunkte beschreiben zudem, ob an einer Stelle ein Hinderniss oder ein frei befahrbarer Raum vorliegt. In Abbildung \ref{fig:Flur} ist zu erkennen, dass die erstellte Karte teilweise verrauscht ist, Wände nicht gerade verlaufen, oder offene Türen und herumlaufende Personen die Messungen verfälschen. Die Karte kann dafür nach der Erstellung von jedem beliebigen Bildbearbeitungsprogramm geöffnet und verändert werden. Dabei ist darauf zu achten die Auflösung nicht zu verändern, da ansonsten die Dimensionen nicht mehr übereinstimmen. Nach der Bearbeitung der Bilddatei kann sie anschließend im Miracenter geladen werden. Mittels Mausklick in die Karte wird die ungefähre Position des Roboters bestimmt. Danach orientiert sich der Scitos automatisch und lokalisiert sich im weiteren Verlauf selbst anhand seiner Sensordaten. Nun können ihm Positionen und Ausrichtung vorgegeben werden und durch seiner internen Pfadplanung steuert er sie autonom an. Durch ein Miracenter-ROS-Interface kann dabei die interne Lokalisierung und die Vorgabe von Position und Ausrichtung vom Scitos extern übermittelt werden. Die gesamte Software ist jedoch proprietär, d.h. nicht quelloffen, sodass ein tieferer Blick in die Funktionsweise der Software dem Nutzer verwehrt bleibt.
\subsection{Android-Studio}
Programm zur Erstellung von Apps.
\subsection{Estimote SDK for Android}
Bibliothek für die Einbindung in eine Android-App. Heir kann schon auf Teile in der App eingegangen werden.
\section{App-Entwicklung}
Was muss die App leisten?
\subsection{ROS-Anbindung}
Kurze Beschreibung des Talkers.
\subsection{Lagemessung}
Auslesen des Gyros und der Komplementärfilterung.
\subsection{Beacon-Detektierung}
Probleme ansprechen mit gleichzeitiger Nutzung von WLAN undBluetooth. Am Ende ein schöner Programmablaufplan.

\section{Experimente}
\subsection{Versuchsplanung}
Nötig?

\subsection{Messung der BLE-Signalausbreitung}
Zuerst werden zwei bis drei Distanzen und dazu die berechnete Distanz aus der App gegenübergestellt. Das wird schlecht sein und aus dem weitren Grund, dass es eine "`Black Box"' ist (d.h. man kann nicht einsehen, wie die Distanz aus dem RSSI-Wert berechnet wird), wird hier geplant ein eigenes Modell aufzustellen. Da wurde entschieden für verschiedene Distanzen nur die RSSI-Werte aufzunehmen, um später ein eigenes Modell zu implementieren.
\begin{figure}[H] 
\centering
\includegraphics[scale=0.3]{Bilder/MessungDistanz1}
\caption{Distanz-Signalstärke-Messung Bild 1}
\end{figure}
\begin{figure}[H] 
\centering
\includegraphics[scale=0.3]{Bilder/MessungDistanz2}
\caption{Distanz-Signalstärke-Messung Bild 2}
\end{figure}
\begin{figure}[H] 
\centering
\includegraphics[scale=0.3]{Bilder/MessungDistanz3}
\caption{Distanz-Signalstärke-Messung Bild 3}
\end{figure}
\subsubsection{Einfluss der Intervalllänge} 
Wird das Rauschen vermindern.
\subsubsection{Einfluss der Signalstärke} 
Dies soll auch in Abhängigkeit zur Signalsstärke passieren, um dessen Ausbreitung zu erforschen.
\subsection{Auswirkung der Smartphone-Ausrichtung}
Hier kommen mal alle Messungen rein. Auch die mit den Beacons an allen drei Himmelsrichtungen.
\begin{figure}[H] 
\centering
\includegraphics[scale=0.3]{Bilder/MessungDrehung}
\caption{Distanz-Signalstärke-Messung bei unterschiedlichen Smartphone-Ausrichtungen}
\end{figure}
\subsection{Einfluss anderer Signalquellen} 
Für die Erklärung aus dem zweiten Kapitel (2,4 Ghz) benötige ich auch die Störung und Interferenzen gleicher Signale. Ich muss ja schließlich erklären, warum ich nicht viele viele iBeacons nebeneinander klatschen kann, um eine möglichst genaue Standortbestimmung zu erhalten (denn die Signale stören sich untereinander). 
ir ist z.B. aufgefallen, dass die Beacons sich gegenseitig in der Sendestärke beeinflussen. Deswegen musste ich Einzelmessungen vornehmen und hier ließe sich auch begründen nicht zu viele Beacons in der realen Anwendung zu plazieren, um durch Elektrosmog nicht zu viele Einflussfaktoren in die Lokalisierung miteinfließen zu lassen. Viel hilft hier nicht immer viel, weniger ist manchmal besser, etc.
\begin{figure}[H] 
\centering
\includegraphics[scale=0.3]{Bilder/MessungBeacon3}
\caption{Gleichzeitige Messung dreier naheliegender Beacon-Signale}
\end{figure}

\subsection{Energieverbrauch eines Beacon} 
Der Wartungsaufwand für ein Beacon hängt maßgeblich an der Laufzeit der in jedem Beacon eingebauten Batterie ab. Die in Kapitel 1 und 2 erwähnten Einstellmöglichkeiten von Sendeleistung und der Häufigkeit von Sendeintervallen beeinflussen dabei den Stromverbrauch der Beacon und somit auch die Betriebsdauer der Batterien. Dieser Abschnitt soll sich damit beschäftigen, inwieweit sich die Parameter auf die Wartungszyklen auswirken. Dies soll später dabei helfen, zwischen der Auslegung der beiden Parameter und des gewünschten Wartungsaufwandes abwägen zu können. Denn in großen Projekten mit mehreren hundert Beacons steigt der Wartungsaufwand proportional und wenn einzelne Beacons andere Einstellungen als die Mehrheit aufweisen (um beispielsweise wichtige Gebiete besser abzudecken), wird auch der Überblick über die nötigen Wartungszyklen verloren gehen. Um die Abhängigkeiten zu veranschaulichen, wird anhand vom Datenblatt des verwendeten Hardware-Chip nRF51822\cite{nRF5} in den genutzten Beacons eine Simulation entworfen, die die Einstellmöglichkeiten als Variablen betrachtet. Als Ausgangsbasis für den Energiespeicher wird eine CR2450-Batterie mit 1,8 Wh\cite{CR2450} angenommen. Hierbei wurde nicht vom Idealzustand ausgegeangen, sondern ein üblicher Faktor von 0,7 hinzu multipliziert, um der Alterung der Zelle und weiterer Effekte Rechnung zu tragen. Durch die gering fliesenden Ströme und der minimalen Bauweise der Beacons, können auch keine direkten Messungen vorgenommen werden. Zudem kann auch nicht verifiziert werden, wie lange ein Sendeauftrag oder ein Zustand vom Prozessor dauert. Um trotzdem ein gutes Simulationsergebnis zu erreichen, muss tiefer in die Funktionsweise der Beacons geschaut werden. Als größte Unbekannte triit dabei die Sendedauer auf. Bei einer angenommenen Datenrate von 250Kbit/s  und bei einer Größe eines Datenpaketes von 38 Bytes \cite{iBPa} (siehe \ref{fig:iBPa}), dauert eine Sendesequenz rund 1 ms. Die benötigte elektrische Leistung für eine vorher definierte Sendeleistung beträgt dabei ein Vielfaches dessen und ist davon stark nichtlinear abhängig. Die dazu nötigen Beziehungen können anhand des Datenblattes des nRF51822 Chips hergeleitet werden. In diesem Fall wurde ein Polynom 4. Grades als Funktion der einstellbaren Sendeleistung aufgstellt, welches annähernd diese Abhängigkeiten beschreibt. Da die Kommunikation bidirektional ist, existiert auch ein Empfangsmodus der ebenfalls mit 1 ms Empfangsdauer angenommen wird, aber dessen Modus hingegen einen konstanten Stromverbrauch aufweist.
\begin{figure}[H]
\centering
\begin{tikzpicture}
    \node [block, fill=magenta!20, text width=2cm, minimum height=1.5cm] (Header) {\small Header \\(2 Bytes)};
    \node [block, fill=magenta!20, right=0cm of Header, text width=3cm, minimum height=1.5cm] (MAC) {\small MAC Addresse \\(6 Bytes)};
    \node [block, fill=magenta!20, right=0cm of MAC, text width=2cm, minimum height=1.5cm] (Data) {\small Data \\(30 Bytes)};
    \node [block, fill=blue!20, below=1cm of Data, text width=2cm, minimum height=1.5cm] (Major) {\small Major\\ (2 Bytes)};
    \node [block, fill=blue!20, left=0cm of Major, text width=3cm, minimum height=1.5cm] (UUID) {\small Proximity UUID \\(16 Bytes)};
    \node [block, fill=blue!20, left=0cm of UUID, text width=3cm, minimum height=1.5cm] (Prefix) {\small iBeacon Prefix \\(9 Bytes)};
    \node [block, fill=blue!20, right=0cm of Major, text width=2cm, minimum height=1.5cm] (Minor) {\small Minor\\ (2 Bytes)};
    \node [block, fill=blue!20, right=0cm of Minor, text width=2cm, minimum height=1.5cm] (TX) {\small TX Power\\ (1 Bytes)};
    \draw[very thick,->] (Data) -- (Major);
\end{tikzpicture}
\caption{Anteile eines Datenpaket in der Beacon-Kommunikation auf der MAC-Ebene}
\label{fig:iBPa}
\end{figure}
Bei den tatsächlichen Laufzeiten des Sende- und Empfangsmodus muss jedoch ein Unsicherheitsfaktor mit eingerechnet werden, sodass nicht der berechnete Wert für eine Übertragung genommen wurde, sondern das Zweifache dessen, um ein weniger idealisiertes Bild für die einzelnen Vorgänge zu gestalten. 
\begin{align*}
t_{TX} &= \text{2 ms} \cdot \text{Intervalle [Hz]} \\
t_{RX} &= \text{2 ms} \cdot \text{1 Hz} \\
t_{CPU} &= t_{TX} + t_{RX} \\
t_{IDLE} &= 1-t_{CPU}
\end{align*}
Da für den Sendevorgang noch zusätzlich der Cortex M0 Prozessor aufgeweckt werden muss und dieser das Paket vorbereitet und bis zum Ende der Sendung abwartet, muss hierfür zusätzlich der Energieverbrauch berechnet werden. Da wie erwähnt eine direkte Leistungsmessung an den Beacons durch die gering fließenden Ströme nicht möglich ist, werden aus dem Datenblatt des Prozessors diese rechnerisch ermittelt. Die aktive Phase des Prozessors für alle Operationen vor und nach einer Sendung werden dabei mit 2 ms Sekunden angenommen, welche exakt der Sende- und Empfangsdauer entspricht. Der Energiebedarf der Recheneinheit wurde im Datenblatt mit 4,1 mA bei einem Takt von 16 MHZ angegeben. So ergibt sich für den Prozessor eine Leistung von 12,3 mW. Zusätzlich wird der Stromverbrauch im IDLE-Modus (Schlafphase des Prozessors) mit 2,6 $\mu$A angegeben. Aus den genannten Gegebenheiten lassen sich nachfolgende Gleichungen erstellen und damit eine Simulation eines Lebenszyklus von einer Batterie näherungsweise bestimmen:
\begin{align*}
E_{Bat} &=& \text{1,8 Wh} \cdot \text{0,7} &=& \text{1,26 Wh}\\
L_{CPU} &=& \text{4,1 mA} \cdot \text{3V} &=& \text{12,3 mW}\\
L_{TX} &=& \text{Polynom 4. Grades (von 4,7 mA }\sim\text{ 11,8 mA)} \cdot \text{3V} &=& \text{14,1 mW} \sim \text{35,4 mW}\\
L_{RX} &=& \text{6,1 mA} \cdot \text{3V} &=& \text{18,3 mW}\\
L_{IDLE} &=& \text{2,6 } \mu\text{A} \cdot \text{3V} &=& \text{7,8 } \mu\text{W}
\end{align*}
ergeben den Zusammenhang
\begin{align*}
t_{Laufzeit} = \frac{E_{Bat}}{L_{CPU}\cdot t_{CPU} + L_{TX}\cdot t_{TX} + L_{RX}\cdot t_{RX} + L_{IDLE}\cdot t_{IDLE}} 
\end{align*}
und dies ergibt folgendes Simulationsergebniss:
%\pgfplotsset{
%    colormap/jet,
%}
%\begin{figure}[H]
%\centering
%\begin{tikzpicture}
%\customrevertcolormap{jet}
%\begin{axis}[
%    colorbar,
%    colorbar style={ylabel=Betriebsstunden},    
%    view={0}{90},
%    xlabel = {$\text{Intervalllänge [ms]}$},
%    ylabel = {$\text{Sendeleistung [dBm]}$},
%    %ytick pos=right,
%    %x dir=reverse,
%    scale=1.5   
%]
%\addplot3[surf, samples=40, samples y=10, domain=50:2000, domain y=-30:-20]
%{1.8/((4.1e-3 * 3 * 4e-3  * 1000/x) + ((4.2e-5 * (-20) ^ 4 + 2.7e-3 * (-20) ^ 3 + 6.1e-2 * (-20) ^ 2 + 0.65 * (-20) + 8) * 1e-3 * 3 * 2e-3 * 1000/x) + ((6.1e-3 * 2e-3 * 2 + 2.6e-6 * (1 - (4e-3  * 1000/x + 2e-3 * 2))) * 3))};
%\addplot3[surf, samples=40, samples y=24, domain=50:2000, domain y=-20:4]
%{1.8/((4.1e-3 * 3 * 4e-3  * 1000/x) + ((4.2e-5 * y ^ 4 + 2.7e-3 * y ^ 3 + 6.1e-2 * y ^ 2 + 0.65 * y + 8) * 1e-3 * 3 * 2e-3 * 1000/x) + ((6.1e-3 * 2e-3 * 2 + 2.6e-6 * (1 - (4e-3  * 1000/x + 2e-3 * 2))) * 3))};
%\end{axis}
%\end{tikzpicture}
%\caption{Einfluss der einstellbaren Parameter auf die Lebensdauer einer CR2450-Batterie}
%\label{fig:iBBatLe}
%\end{figure}
Aufgrund der getroffenen Annahmen würde eine Batterie in den niedrigsten Einstellungen für rund 2 Jahre den Betrieb eines Beacon ermöglichen. Im realen Betrieb hatte sich gezeigt, dass eine Batterie schon nach 4 bis 5 Monaten gewechselt werden musste. Während dieser Zeit wurden die Einstellungen nicht geändert und bei einer Intervalllänge von 5 Hz und Sendeleistung von -12 dBm belassen. Beides stimmt mit der Simulation ungefähr überein, was noch kein Beweis für die Gultigkeit der Annahmen bedeutet, jedoch wird der qualitative Verlauf der wechselseitigen Beziehungen von Einstellparameter und Batterielaufzeit skizziert, welcher als Orientierung zur Auslegung der Parameter benutzt werden kann.